// ------------------------------------------------------------
// UPDATE COMPONENT COMMAND 
// ------------------------------------------------------------
/*
updateComponent: 
    - Should be able to update everything except for 
      variations and modifiers (even nested properties)
    - Will update properties by first getting a list of available 
      properties to update
    - This will be generated by getComponentKeysDeep 
*/


// REQUIRES
// ------------------------------------------------------------
const store = require('../store');
const utils = require('../utils');
const vars = utils.vars;
const N = vars.N;


// EXPORT
// ------------------------------------------------------------
module.exports = function (vorpal) {
    let chalk = vorpal.chalk;
    vorpal
    .command('update <type> <name>')
    .validate(function (args) {
        let nameValidationResult = utils.validateName(args.name);
        let typeValidationResult = utils.validateType(args.type);    
        if (nameValidationResult) {
            return nameValidationResult;
        } else if (typeValidationResult) {
            return typeValidationResult;
        } else {
            return true;
        } 
    })
    .parse(function (command, args) {
        // Auto pipe the result to pretty-print 
        return command + ' | pretty';
    })
    .action(function(args, callback) {         
        let updateableProperties;
        let propertyToUpdate;
        let valueToUpdate;
        let self = this;      
        // Set updateableProperties based on type
        if (args.type === 'atom' || args.type === 'molecule') {
            updateableProperties = vars.atomPropertyChoicesDeep;
        } else if (args.type === 'organism') {
            updateableProperties = vars.organismPropertyChoicesDeep;
        } else if (args.type === 'template') {
            updateableProperties = vars.templatePropertyChoicesDeep;
        } else {
            updateableProperties = [];
        }
        let message = `Please choose the property you wish to update.`;                                                
        self.prompt({
            type: 'list',
            name: 'updatePropertyChooser',
            choices: updateableProperties,
            message: message
        }, (answer) => {            
            if (answer.updatePropertyChooser) {
                propertyToUpdate = answer.updatePropertyChooser;
                let message2 = `Please input the new value for the property "${propertyToUpdate}": `;
                self.prompt({
                    type: 'input',
                    name: 'updateValueInput',
                    message: message2,
                    validate: function (nextAnswer) { 
                        let value = nextAnswer;
                        let errMessage = "";
                        // console.log(propertyToUpdate);
                        if (propertyToUpdate === "name") {
                            errMessage = utils.validateName(value); 
                            if (value !== "true" && value !== "false" && !errMessage) {
                                return true; 
                            }                
                        } else if (propertyToUpdate === "type") {
                            errMessage = utils.validateType(value);
                            if (value !== "true" && value !== "false" && !errMessage) {
                                return true; 
                            } 
                        } else {
                            if (value === "true" || value === "false") {
                                return true; 
                            }
                            errMessage = 'Values can only be "true" or "false"';  
                        }
                        self.log(`The ${propertyToUpdate} property can not be set to ${value}. ${N}` + errMessage + `${N}`);
                    }
                }, (nextAnswer) => {
                    if (nextAnswer) {
                        valueToUpdate = nextAnswer.updateValueInput;
                        try {
                            var updatedComponent = store.updateComponent(args.name, propertyToUpdate, valueToUpdate);                        
                            self.log(updatedComponent);
                            callback();
                            return;                                   
                        } catch (error) {
                            self.log(error);
                            callback();
                        }
                    } else {
                        self.log('component not updated');
                        callback();
                        return;
                    }  
                });                                
            } else {
                self.log('component not updated');
                callback();
                return;
            }                      
        });        
    });
};